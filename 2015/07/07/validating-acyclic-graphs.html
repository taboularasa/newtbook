<!doctype html>
<html>
  <head>
    <link href="../../../stylesheets/all-bb815f9b.css" rel="stylesheet" type="text/css" />
    <meta charset="utf-8" />
    <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1' />
    <title>Blog Title - Validating acyclic graphs</title>
    <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" />
  </head>
  <body>

      <h1>Validating acyclic graphs</h1>
    <div id="main" role="main">
      <p><a href="https://github.com/lexi-lambda">Alexis King</a> and I were building an inventory management system for a Widget factory. In the warehouse they have a variety of containers that can hold either widgets or other containers. We needed to provide an inventory management system for the warehouse manager to keep track of the whereabouts of each container and widget. Here&#39;s how it needed to work:</p>

<ol>
<li>Manager logs into the inventory management system</li>
<li>Manager navigates to the show view for an Inventory Location (i.e. a warehouse)</li>
<li>Manager clicks on manage containers</li>
<li>From this form the Manager can specify the location of Containers using a drag and drop style interface.</li>
</ol>

<p>So based on these requirements we know that a <code>Container</code> should <code>belong_to :parent_container</code> and inversely <code>have_many :child_containers</code>:</p>
<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Container</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:inventory_location</span>
  <span class="n">belongs_to</span> <span class="ss">:parent_container</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s1">'Container'</span><span class="p">,</span> <span class="ss">foreign_key: :container_id</span>
  <span class="n">has_many</span> <span class="ss">:child_containers</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s1">'Container'</span><span class="p">,</span> <span class="ss">foreign_key: :container_id</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>Sounds great so far! Wait, one problem is we want to make sure that a warehouse manager can&#39;t define a cyclic relationship of containers. Container <em>A</em> can not be inside of container <em>B</em> if container <em>B</em> is already inside of container <em>A</em>.</p>
<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18</pre></td><td class="code"><pre><span class="n">describe</span> <span class="no">Container</span> <span class="k">do</span>
  <span class="n">it</span> <span class="s1">'can add child containers'</span> <span class="k">do</span>
    <span class="n">location</span> <span class="o">=</span> <span class="no">InventoryLocation</span><span class="p">.</span><span class="nf">create</span>
    <span class="n">container_a</span> <span class="o">=</span> <span class="n">location</span><span class="p">.</span><span class="nf">containers</span><span class="p">.</span><span class="nf">create</span>
    <span class="n">container_b</span> <span class="o">=</span> <span class="n">location</span><span class="p">.</span><span class="nf">containers</span><span class="p">.</span><span class="nf">create</span>
    <span class="n">expect</span><span class="p">(</span><span class="n">container_a</span><span class="p">.</span><span class="nf">child_containers</span> <span class="o">&lt;&lt;</span> <span class="n">container_b</span><span class="p">).</span><span class="nf">to</span> <span class="n">eq</span><span class="p">(</span><span class="kp">true</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">it</span> <span class="s1">'does not add a child container if a cycle would be formed'</span> <span class="k">do</span>
    <span class="n">location</span> <span class="o">=</span> <span class="no">InventoryLocation</span><span class="p">.</span><span class="nf">create</span>
    <span class="n">container_a</span> <span class="o">=</span> <span class="n">location</span><span class="p">.</span><span class="nf">containers</span><span class="p">.</span><span class="nf">create</span>
    <span class="n">container_b</span> <span class="o">=</span> <span class="n">location</span><span class="p">.</span><span class="nf">containers</span><span class="p">.</span><span class="nf">create</span>
    <span class="n">container_a</span><span class="p">.</span><span class="nf">child_containers</span> <span class="o">&lt;&lt;</span> <span class="n">container_b</span>
    <span class="n">container_b</span><span class="p">.</span><span class="nf">child_containers</span> <span class="o">&lt;&lt;</span> <span class="n">container_a</span>
    <span class="n">expect</span><span class="p">(</span><span class="n">container_b</span><span class="p">.</span><span class="nf">errors</span><span class="p">[</span><span class="ss">:base</span><span class="p">])</span>
      <span class="p">.</span><span class="nf">to</span> <span class="kp">include</span><span class="p">(</span><span class="s1">'Creates cyclic container relationship'</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>Sounds obvious but finding a way to validate that for any case turns out to be a little complicated. Luckily we don&#39;t need to figure that out because <a href="https://en.wikipedia.org/wiki/Robert_Tarjan">Robert Tarjan</a> already <a href="https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm">did</a> and Ruby makes it available in the <code>TSort</code> module. This is the same module that <a href="http://bundler.io/">Bundler</a> uses to resolve dependancies in a Gemfile. If it&#39;s good enough for Bundler it should be good enough for this!</p>

<p>We don&#39;t really need all the functionality of the <code>TSort</code> module but if we include it in our model and call it&#39;s <code>#tsort</code> method, we&#39;ll conveniently raise a <code>TSort::Cyclic</code> error if any closed loops exist in the tree! Great. <code>TSort</code> expects the including class to implement an interface of <code>#tsort_each_node</code> and <code>#tsort_each_child</code>. The implementation depends on your use case but in this scenario it looks like this:</p>
<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">InventoryLocation</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="kp">include</span> <span class="no">TSort</span>

  <span class="n">has_many</span> <span class="ss">:containers</span>

  <span class="n">validate</span> <span class="ss">:acyclic</span>

  <span class="kp">private</span>

  <span class="k">def</span> <span class="nf">acyclic</span>
    <span class="n">tsort</span>
  <span class="k">rescue</span> <span class="no">TSort</span><span class="o">::</span><span class="no">Cyclic</span>
    <span class="n">errors</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="ss">:base</span><span class="p">,</span> <span class="s1">'Creates cyclic container relationship'</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">tsort_each_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="n">containers</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">tsort_each_child</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="n">container</span><span class="p">.</span><span class="nf">child_containers</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>Now the problem is we want to interact with a tree of <code>Container</code>s but when we modify their relationship we need to check for cycles in the tree through the <code>InventoryLocation</code>. For that to work <code>InventoryLocation#valid?</code> needs to be called <em>after</em> the update. This can be accomplished by combining the update and the check for validity in a transaction. It&#39;s essential this transaction is run anytime a container is added to another container. We can accomplish that with an extension to the <code>ActiveRecord_Associations_CollectionProxy</code> like so:</p>
<div class="highlight ruby"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18</pre></td><td class="code"><pre><span class="k">module</span> <span class="nn">ValidateAcyclicInventoryLocation</span>
  <span class="k">def</span> <span class="nf">with_location_validation</span>
    <span class="n">transaction</span> <span class="k">do</span>
      <span class="k">yield</span>
      <span class="n">owner</span> <span class="o">=</span> <span class="n">proxy_association</span><span class="p">.</span><span class="nf">owner</span>
      <span class="n">location</span> <span class="o">=</span> <span class="n">owner</span><span class="p">.</span><span class="nf">inventory_location</span><span class="p">.</span><span class="nf">reload</span>
      <span class="k">return</span> <span class="kp">true</span> <span class="k">if</span> <span class="n">location</span><span class="p">.</span><span class="nf">valid?</span>

      <span class="n">location</span><span class="p">.</span><span class="nf">errors</span><span class="p">.</span><span class="nf">full_messages_for</span><span class="p">(</span><span class="ss">:base</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">error</span><span class="o">|</span>
        <span class="n">owner</span><span class="p">.</span><span class="nf">errors</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="ss">:base</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">&lt;&lt;</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="n">with_location_validation</span> <span class="p">{</span> <span class="k">super</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</div>

<p>Then we can mix that extension into the <code>has_many</code> call on <code>Container</code>:
```ruby
class Container &lt; ActiveRecord::Base
  belongs_to :inventory_location</p>

<p>belongs_to(
    :parent_container,
    class_name: &#39;Container&#39;,
    foreign_key: :container_id
  )</p>

<p>has_many(
    :child_containers,
    (-&gt; { extending ValidateAcyclicInventoryLocation }),
    class_name: &#39;Container&#39;,
    foreign_key: :container_id
  )
end
```</p>

<p>And with that our tests should be passing! Good work :+1:</p>

<p>p.s. If you&#39;re interested I&#39;ve posted the example repo <a href="https://github.com/taboularasa/tsort_test">here</a></p>

    </div>

    <aside>
      <h2>Recent Articles</h2>
      <ol>
          <li><a href="../29/delegating-concern.html">Delegating Concern</a> <span>Jul 29</span></li>
          <li><a href="validating-acyclic-graphs.html">Validating acyclic graphs</a> <span>Jul  7</span></li>
          <li><a href="../../05/20/rails-broke-ngrok.html">Rails 4.2 broke Ngrok</a> <span>May 20</span></li>
          <li><a href="../../05/18/virtual-inventory-location.html">Virtual Inventory Location</a> <span>May 18</span></li>
          <li><a href="../../05/15/generic-devise-layout-lookup.html">Generic Devise Layout Lookup</a> <span>May 15</span></li>
          <li><a href="../../05/13/broken-promises.html">Broken Promises</a> <span>May 13</span></li>
          <li><a href="../../05/06/find-ifnone.html">Enumerable#find ifnone</a> <span>May  6</span></li>
          <li><a href="../../05/05/delegation.html">Delegation</a> <span>May  5</span></li>
          <li><a href="../../05/04/class-extraction.html">Class Extraction</a> <span>May  4</span></li>
      </ol>
    </aside>
  </body>
</html>
